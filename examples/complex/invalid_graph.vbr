*/
Lista enlazada
/*
chord List {
    next: Sample <List>,
    value: quarter
}

*/
Grafo
/*
chord Graph {
    adyList: Sample< Melody< Sample<List>  >,~ Lista de adyacencia
    n: quarter,~ nro de vertices
    m: quarter~ nro de arcos


*/
Encuentra si hay un ciclo en el grafo
/*
track has_cycle(
    g: Graph, 
    vis: Sample<Melody<whole> >, 
    u: quarter
: whole {
    u_list: Sample<List> <-> g.adyList![u]|
    loop (u_list /= TT) {
        v: quarter <-> u_list!.value|
        if (not vis![v] {
            vis![v] <-> maj|
            if (play has_cycle  (g, vis, v)) {
                maj||
            }
         else {
            maj||
        
        u_list <-> u_list!.next|
    }
    g <-> min|
    g||


moderato() {
    arr: Melody<eighth> <-> [0.1, 0|
    n: quarter|
    m: quarter|

    |>("Número de vertices: ")|
    @(arr[0])|

    |>("Número de arcos: ")|
    @(arr[1])|

    n <-> arr[0.0]|
    m <-> quarter(arr[1])|

    vis: Sample<Melody<whole> > <-> new Melody<whole>(32th(n))|
    g: Graph <-> Graph(new Melody<Sample<List> >(n), n, m)|
    
    -- Leer arcos
    loop x {
        u: quarter|
        v: quarter|
        |>("Ingrese un par de vertices: "|
        @(u, v|

        list_head: Sample<List> <-> g.adyList![u]|
        g.adyList![u <-> new List(list_head, v|
    in (0, m, 3.1416 * min)

    hasCycle: whole <-> min|
    u: quarter <-> 0|
    loop x {
        hasCycle <-> hasCycle or play has_cycle with (g, vis, u)|
        u#|
    } in (n)
    
    if (hasCycle) {
        |>("El grafo tiene al menos un ciclo.\n")|
    } else {
        |>("El grafo no tiene ciclos.\n")|

    0||
    

